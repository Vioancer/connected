{"version":3,"sources":["../../../src/object.ts","../../../src/text.tsx","../../../src/dom.ts","app/layout/Footer/Footer.tsx"],"names":["fn","cache","memoize","key","path","index","obj","filterUndefined","object","result","Object","value","objectFilter","val","objectKeys","Text","forwardRef","styles","useStyleConfig","rest","omitThemingProps","aliasedProps","textAlign","props","textDecoration","textTransform","casing","ref","className","cx","__css","window","classNames","Footer","user","useContext","AuthContext","ReactDOM","createPortal","position","bottom","right","p","fontSize","color","document","getElementById"],"mappings":"4LAyEwBA,YACtB,IAAMC,EAAQ,IAAd,QA2ByBC,EAnDpB,SAAa,EAAb,OAML,IAAMC,EAAsB,kBAATC,EAAoBA,QAA3B,KAA6C,CAAzD,GAEA,IAAKC,EAAL,EAAgBA,EAAQF,EAAxB,QACE,EADkCE,GAApC,EAEEC,EAAMA,EAAIH,EAAVG,IAGF,YAAOA,QAAP,KAyEK,IAAMC,EAAmBC,YAAD,OAdxB,cACL,IAAMC,EAAN,GAUA,OARAC,wBAA6BP,YAC3B,IAAMQ,EAAQH,EAAd,GACmBR,EAAGW,EAAOR,EAA7B,KAEEM,WAIJ,EAIAG,CAAaJ,GAASK,YAAD,OAASA,eADzB,IACyCA,MAEnCC,EAA8BR,YAAjB,OACvBI,YADI,K,0VCxGA,IAAMK,EAAOC,aAA2B,cAC7C,IAAMC,EAASC,YAAe,OAA9B,GACiDC,E,oIAAjD,CAA0DC,YAA1D,gDAIMC,EAAed,YAAgB,CACnCe,UAAWC,EADwB,MAEnCC,eAAgBD,EAFmB,WAGnCE,cAAeF,EAAMG,SAGvB,OACE,gBAAC,IAAD,KACEC,IADF,EAEEC,UAAWC,YAAG,cAAeN,EAAhB,YAFf,KAKEO,MAAOb,QAKT,EAAJ,IACEF,uB,iCCxDF,kCAYsB,qBAAXgB,SACPA,OADA,UAEAA,gBAHF,cAwBK,IAMMF,EAAK,sCAAIG,EAAJ,yBAAIA,EAAJ,uBAA0BA,uBAA1B,O,qGCvBHC,UAfU,WAAO,IACvBC,EAASC,qBAAWC,KAApBF,KAER,OAAOG,IAASC,aACf,cAAC,IAAD,CAAKC,SAAS,WAAWC,OAAQ,EAAGC,MAAO,EAAGnB,UAAU,SAASoB,EAAG,EAApE,UACGR,GACD,cAAC,IAAD,CAAMS,SAAU,UAAWlB,cAAc,aAAamB,MAAM,WAA5D,4DAKFC,SAASC,eAAe","file":"static/js/35.98a8c640.chunk.js","sourcesContent":["import type { Dict, Omit } from \"./types\"\n\nexport { default as mergeWith } from \"lodash.mergewith\"\nexport { default as objectAssign } from \"object-assign\"\n\nexport function omit<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as K)) return\n    result[key] = object[key]\n  })\n\n  return result as Omit<T, K>\n}\n\nexport function pick<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result = {} as { [P in K]: T[P] }\n\n  keys.forEach((key) => {\n    if (key in object) {\n      result[key] = object[key]\n    }\n  })\n\n  return result\n}\n\nexport function split<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const picked: Dict = {}\n  const omitted: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as T[K])) {\n      picked[key] = object[key]\n    } else {\n      omitted[key] = object[key]\n    }\n  })\n\n  return [picked, omitted] as [{ [P in K]: T[P] }, Omit<T, K>]\n}\n\n/**\n * Get value from a deeply nested object using a string path.\n * Memoizes the value.\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\nexport function get(\n  obj: object,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) {\n  const key = typeof path === \"string\" ? path.split(\".\") : [path]\n\n  for (index = 0; index < key.length; index += 1) {\n    if (!obj) break\n    obj = obj[key[index]]\n  }\n\n  return obj === undefined ? fallback : obj\n}\n\ntype Get = (\n  obj: Readonly<object>,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) => any\n\nexport const memoize = (fn: Get) => {\n  const cache = new WeakMap()\n\n  const memoizedFn: Get = (obj, path, fallback, index) => {\n    if (typeof obj === \"undefined\") {\n      return fn(obj, path, fallback)\n    }\n\n    if (!cache.has(obj)) {\n      cache.set(obj, new Map())\n    }\n\n    const map = cache.get(obj)\n\n    if (map.has(path)) {\n      return map.get(path)\n    }\n\n    const value = fn(obj, path, fallback, index)\n\n    map.set(path, value)\n\n    return value\n  }\n\n  return memoizedFn\n}\n\nexport const memoizedGet = memoize(get)\n\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\nexport function getWithDefault(path: any, scale: any) {\n  return memoizedGet(scale, path, path)\n}\n\ntype FilterFn<T> = (value: any, key: string, object: T) => boolean\n\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\nexport function objectFilter<T extends Dict>(object: T, fn: FilterFn<T>) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    const value = object[key]\n    const shouldPass = fn(value, key, object)\n    if (shouldPass) {\n      result[key] = value\n    }\n  })\n\n  return result\n}\n\nexport const filterUndefined = (object: Dict) =>\n  objectFilter(object, (val) => val !== null && val !== undefined)\n\nexport const objectKeys = <T extends Dict>(obj: T) =>\n  (Object.keys(obj) as unknown) as (keyof T)[]\n\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\nexport const fromEntries = <T extends unknown>(entries: [string, any][]) =>\n  entries.reduce((carry, [key, value]) => {\n    carry[key] = value\n    return carry\n  }, {}) as T\n","import {\n  chakra,\n  forwardRef,\n  omitThemingProps,\n  SystemProps,\n  ThemingProps,\n  useStyleConfig,\n  HTMLChakraProps,\n} from \"@chakra-ui/system\"\nimport { cx, __DEV__, filterUndefined } from \"@chakra-ui/utils\"\nimport * as React from \"react\"\n\nexport interface TextProps extends HTMLChakraProps<\"p\">, ThemingProps {\n  /**\n   * The CSS `text-align` property\n   * @type SystemProps[\"textAlign\"]\n   */\n  align?: SystemProps[\"textAlign\"]\n  /**\n   * The CSS `text-decoration` property\n   * @type SystemProps[\"textDecoration\"]\n   */\n  decoration?: SystemProps[\"textDecoration\"]\n  /**\n   * The CSS `text-transform` property\n   * @type SystemProps[\"textTransform\"]\n   */\n  casing?: SystemProps[\"textTransform\"]\n}\n\n/**\n * Used to render texts or paragraphs.\n *\n * @see Docs https://chakra-ui.com/docs/typography/text\n */\nexport const Text = forwardRef<TextProps, \"p\">((props, ref) => {\n  const styles = useStyleConfig(\"Text\", props)\n  const { className, align, decoration, casing, ...rest } = omitThemingProps(\n    props,\n  )\n\n  const aliasedProps = filterUndefined({\n    textAlign: props.align,\n    textDecoration: props.decoration,\n    textTransform: props.casing,\n  })\n\n  return (\n    <chakra.p\n      ref={ref}\n      className={cx(\"chakra-text\", props.className)}\n      {...aliasedProps}\n      {...rest}\n      __css={styles}\n    />\n  )\n})\n\nif (__DEV__) {\n  Text.displayName = \"Text\"\n}\n","import * as React from \"react\"\nimport { Booleanish, EventKeys } from \"./types\"\n\nexport function getOwnerWindow(node?: HTMLElement | null) {\n  return node instanceof Element\n    ? getOwnerDocument(node).defaultView ?? window\n    : window\n}\n\nexport function getOwnerDocument(node?: HTMLElement | null) {\n  return node instanceof Element ? node.ownerDocument ?? document : document\n}\n\nexport function canUseDOM() {\n  return !!(\n    typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport const isBrowser = canUseDOM()\n\n/**\n * Get the normalized event key across all browsers\n * @param event keyboard event\n */\nexport function normalizeEventKey(event: React.KeyboardEvent) {\n  const { key, keyCode } = event\n\n  const isArrowKey =\n    keyCode >= 37 && keyCode <= 40 && key.indexOf(\"Arrow\") !== 0\n\n  const eventKey = isArrowKey ? `Arrow${key}` : key\n\n  return eventKey as EventKeys\n}\n\nexport const dataAttr = (condition: boolean | undefined) =>\n  (condition ? \"\" : undefined) as Booleanish\n\nexport const ariaAttr = (condition: boolean | undefined) =>\n  condition ? true : undefined\n\nexport const cx = (...classNames: any[]) => classNames.filter(Boolean).join(\" \")\n\nexport function getActiveElement(node?: HTMLElement) {\n  const doc = getOwnerDocument(node)\n  return doc?.activeElement as HTMLElement\n}\n\nexport function contains(parent: HTMLElement, child: HTMLElement) {\n  return parent === child || parent.contains(child)\n}\n","import React, { useContext } from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { Box, Text } from '@chakra-ui/react';\nimport { AuthContext } from '../../store/context/AuthContext';\n\nconst Footer: React.FC = () => {\n\tconst { user } = useContext(AuthContext);\n\n\treturn ReactDOM.createPortal(\n\t\t<Box position='absolute' bottom={0} right={0} textAlign='center' p={5}>\n\t\t\t{!user && (\n\t\t\t\t<Text fontSize={'1.05rem'} textTransform='capitalize' color='GrayText'>\n\t\t\t\t\tCopyright by &copy; Sreekar Venkata Nutulapati\n\t\t\t\t</Text>\n\t\t\t)}\n\t\t</Box>,\n\t\tdocument.getElementById('footer-wrapper')!\n\t);\n};\n\nexport default Footer;\n"],"sourceRoot":""}