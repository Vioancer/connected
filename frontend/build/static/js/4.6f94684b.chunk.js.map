{"version":3,"sources":["../../../src/react-helpers.ts","../../../src/form-control.tsx","../../../src/assertion.ts","../../../src/use-boolean.ts","../../../src/dom.ts","../../../src/object.ts","../../../src/function.ts","../../../src/use-form-control.ts","../../../src/form-label.tsx","../../../src/icon.tsx","../../../src/form-error.tsx","../../../src/input.tsx"],"names":["options","strict","errorMessage","name","Context","React","context","Error","createContext","FormControl","forwardRef","styles","useMultiStyleConfig","props","id","isReadOnly","uuid","useId","idProp","labelId","feedbackId","helpTextId","useBoolean","isRequired","isInvalid","isDisabled","isFocused","onFocus","setFocus","onBlur","hasFeedbackText","setHasFeedbackText","hasHelpText","setHasHelpText","htmlProps","useFormControlProvider","omitThemingProps","_className","cx","value","role","ref","className","__css","width","position","FormHelperText","field","useFormControlContext","useStyles","useSafeLayoutEffect","helperText","isFunction","__DEV__","process","initialState","useState","on","useCallback","setValue","off","toggle","prev","window","dataAttr","condition","ariaAttr","classNames","fn","cache","memoize","key","path","index","obj","callAllHandlers","fns","event","once","args","result","message","console","useFormControl","describedBy","ariaDescribedBy","Object","keys","object","omit","disabled","readOnly","required","FormLabel","useStyleConfig","requiredIndicator","ownProps","htmlFor","useFieldLabel","display","textAlign","RequiredIndicator","aria-hidden","children","fallbackIcon","stroke","strokeWidth","strokeLinecap","fill","d","strokeMiterlimit","cy","r","viewBox","Icon","as","color","focusable","shared","w","h","lineHeight","flexShrink","_viewBox","element","_path","verticalAlign","FormErrorMessage","aria-live","alignItems","FormErrorIcon","Input","input"],"mappings":"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","file":"static/js/4.6f94684b.chunk.js","sourcesContent":["import * as React from \"react\"\nimport { isFunction } from \"./assertion\"\n\nexport interface CreateContextOptions {\n  /**\n   * If `true`, React will throw if context is `null` or `undefined`\n   * In some cases, you might want to support nested context, so you can set it to `false`\n   */\n  strict?: boolean\n  /**\n   * Error message to throw if the context is `undefined`\n   */\n  errorMessage?: string\n  /**\n   * The display name of the context\n   */\n  name?: string\n}\n\ntype CreateContextReturn<T> = [React.Provider<T>, () => T, React.Context<T>]\n\n/**\n * Creates a named context, provider, and hook.\n *\n * @param options create context options\n */\nexport function createContext<ContextType>(options: CreateContextOptions = {}) {\n  const {\n    strict = true,\n    errorMessage = \"useContext: `context` is undefined. Seems you forgot to wrap component within the Provider\",\n    name,\n  } = options\n\n  const Context = React.createContext<ContextType | undefined>(undefined)\n\n  Context.displayName = name\n\n  function useContext() {\n    const context = React.useContext(Context)\n\n    if (!context && strict) {\n      throw new Error(errorMessage)\n    }\n\n    return context\n  }\n\n  return [\n    Context.Provider,\n    useContext,\n    Context,\n  ] as CreateContextReturn<ContextType>\n}\n\n/**\n * Gets only the valid children of a component,\n * and ignores any nullish or falsy child.\n *\n * @param children the children\n */\nexport function getValidChildren(children: React.ReactNode) {\n  return React.Children.toArray(children).filter((child) =>\n    React.isValidElement(child),\n  ) as React.ReactElement[]\n}\n\ntype ReactRef<T> = React.Ref<T> | React.RefObject<T> | React.MutableRefObject<T>\n\n/**\n * Assigns a value to a ref function or object\n *\n * @param ref the ref to assign to\n * @param value the value\n */\nexport function assignRef<T = any>(ref: ReactRef<T> | undefined, value: T) {\n  if (ref == null) return\n\n  if (isFunction(ref)) {\n    ref(value)\n    return\n  }\n\n  try {\n    // @ts-ignore\n    ref.current = value\n  } catch (error) {\n    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`)\n  }\n}\n\n/**\n * Combine multiple React refs into a single ref function.\n * This is used mostly when you need to allow consumers forward refs to\n * internal components\n *\n * @param refs refs to assign to value to\n */\nexport function mergeRefs<T>(...refs: (ReactRef<T> | undefined)[]) {\n  return (value: T) => {\n    refs.forEach((ref) => assignRef(ref, value))\n  }\n}\n","import { useBoolean, useId, useSafeLayoutEffect } from \"@chakra-ui/hooks\"\nimport {\n  chakra,\n  forwardRef,\n  omitThemingProps,\n  StylesProvider,\n  ThemingProps,\n  useMultiStyleConfig,\n  useStyles,\n  HTMLChakraProps,\n} from \"@chakra-ui/system\"\nimport { createContext, cx, __DEV__ } from \"@chakra-ui/utils\"\nimport * as React from \"react\"\n\nexport interface FormControlOptions {\n  /**\n   * If `true`, the form control will be required. This has 2 side effects:\n   * - The `FormLabel` will show a required indicator\n   * - The form element (e.g, Input) will have `aria-required` set to `true`\n   */\n  isRequired?: boolean\n  /**\n   * If `true`, the form control will be disabled. This has 2 side effects:\n   * - The `FormLabel` will have `data-disabled` attribute\n   * - The form element (e.g, Input) will be disabled\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the form control will be invalid. This has 2 side effects:\n   * - The `FormLabel` and `FormErrorIcon` will have `data-invalid` set to `true`\n   * - The form element (e.g, Input) will have `aria-invalid` set to `true`\n   */\n  isInvalid?: boolean\n  /**\n   * If `true`, the form control will be readonly\n   */\n  isReadOnly?: boolean\n}\n\ninterface FormControlContext extends FormControlOptions {\n  /**\n   * The label text used to inform users as to what information is\n   * requested for a text field.\n   */\n  label?: string\n  /**\n   * The custom `id` to use for the form control. This is passed directly to the form element (e.g, Input).\n   * - The form element (e.g Input) gets the `id`\n   * - The form label id: `form-label-${id}`\n   * - The form error text id: `form-error-text-${id}`\n   * - The form helper text id: `form-helper-text-${id}`\n   */\n  id?: string\n}\n\ntype ControlContext = Omit<\n  ReturnType<typeof useFormControlProvider>,\n  \"htmlProps\"\n>\n\nconst [\n  FormControlProvider,\n  useFormControlContext,\n] = createContext<ControlContext>({\n  strict: false,\n  name: \"FormControlContext\",\n})\n\nexport { useFormControlContext }\n\nfunction useFormControlProvider(props: FormControlContext) {\n  const {\n    id: idProp,\n    isRequired,\n    isInvalid,\n    isDisabled,\n    isReadOnly,\n    ...htmlProps\n  } = props\n\n  // Generate all the required ids\n  const uuid = useId()\n  const id = idProp || `field-${uuid}`\n\n  const labelId = `${id}-label`\n  const feedbackId = `${id}-feedback`\n  const helpTextId = `${id}-helptext`\n\n  /**\n   * Track whether the `FormErrorMessage` has been rendered.\n   * We use this to append its id the the `aria-describedby` of the `input`.\n   */\n  const [hasFeedbackText, setHasFeedbackText] = useBoolean()\n\n  /**\n   * Track whether the `FormHelperText` has been rendered.\n   * We use this to append its id the the `aria-describedby` of the `input`.\n   */\n  const [hasHelpText, setHasHelpText] = useBoolean()\n\n  // Track whether the form element (e.g, `input`) has focus.\n  const [isFocused, setFocus] = useBoolean()\n\n  const context = {\n    isRequired: !!isRequired,\n    isInvalid: !!isInvalid,\n    isReadOnly: !!isReadOnly,\n    isDisabled: !!isDisabled,\n    isFocused: !!isFocused,\n    onFocus: setFocus.on,\n    onBlur: setFocus.off,\n    hasFeedbackText,\n    setHasFeedbackText,\n    hasHelpText,\n    setHasHelpText,\n    id,\n    labelId,\n    feedbackId,\n    helpTextId,\n    htmlProps,\n  }\n\n  return context\n}\n\nexport interface FormControlProps\n  extends HTMLChakraProps<\"div\">,\n    ThemingProps,\n    FormControlContext {}\n\n/**\n * FormControl provides context such as\n * `isInvalid`, `isDisabled`, and `isRequired` to form elements.\n *\n * This is commonly used in form elements such as `input`,\n * `select`, `textarea`, etc.\n */\nexport const FormControl = forwardRef<FormControlProps, \"div\">((props, ref) => {\n  const styles = useMultiStyleConfig(\"Form\", props)\n  const ownProps = omitThemingProps(props)\n  const { htmlProps, ...context } = useFormControlProvider(ownProps)\n\n  const _className = cx(\"chakra-form-control\", props.className)\n\n  return (\n    <FormControlProvider value={context}>\n      <StylesProvider value={styles}>\n        <chakra.div\n          role=\"group\"\n          ref={ref}\n          {...htmlProps}\n          className={_className}\n          __css={{\n            width: \"100%\",\n            position: \"relative\",\n          }}\n        />\n      </StylesProvider>\n    </FormControlProvider>\n  )\n})\n\nif (__DEV__) {\n  FormControl.displayName = \"FormControl\"\n}\n\nexport interface HelpTextProps extends HTMLChakraProps<\"div\"> {}\n\n/**\n * FormHelperText\n *\n * Assistive component that conveys additional guidance\n * about the field, such as how it will be used and what\n * types in values should be provided.\n */\nexport const FormHelperText = forwardRef<HelpTextProps, \"div\">((props, ref) => {\n  const field = useFormControlContext()\n  const styles = useStyles()\n\n  /**\n   * Notify the field context when the help text is rendered on screen,\n   * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).\n   */\n  useSafeLayoutEffect(() => {\n    field?.setHasHelpText.on()\n    return () => field?.setHasHelpText.off()\n  }, [])\n\n  const _className = cx(\"chakra-form__helper-text\", props.className)\n\n  return (\n    <chakra.div\n      ref={ref}\n      __css={styles.helperText}\n      {...props}\n      className={_className}\n      id={props.id ?? field?.helpTextId}\n    />\n  )\n})\n\nif (__DEV__) {\n  FormHelperText.displayName = \"FormHelperText\"\n}\n","import { ChangeEvent } from \"react\"\nimport { Dict } from \"./types\"\n\n// Number assertions\nexport function isNumber(value: any): value is number {\n  return typeof value === \"number\"\n}\n\nexport const isNotNumber = (value: any) =>\n  typeof value !== \"number\" || Number.isNaN(value) || !Number.isFinite(value)\n\nexport function isNumeric(value: any) {\n  return value != null && value - parseFloat(value) + 1 >= 0\n}\n\n// Array assertions\nexport function isArray<T>(value: any): value is Array<T> {\n  return Array.isArray(value)\n}\n\nexport const isEmptyArray = (value: any) => isArray(value) && value.length === 0\n\n// Function assertions\nexport function isFunction(value: any): value is Function {\n  return typeof value === \"function\"\n}\n\n// Generic assertions\nexport const isDefined = (value: any) =>\n  typeof value !== \"undefined\" && value !== undefined\n\nexport const isUndefined = (value: any): value is undefined =>\n  typeof value === \"undefined\" || value === undefined\n\n// Object assertions\nexport const isObject = (value: any): value is Dict => {\n  const type = typeof value\n  return (\n    value != null &&\n    (type === \"object\" || type === \"function\") &&\n    !isArray(value)\n  )\n}\n\nexport const isEmptyObject = (value: any) =>\n  isObject(value) && Object.keys(value).length === 0\n\nexport function isNotEmptyObject(value: any): value is object {\n  return value && !isEmptyObject(value)\n}\n\nexport const isNull = (value: any): value is null => value == null\n\n// String assertions\nexport function isString(value: any): value is string {\n  return Object.prototype.toString.call(value) === \"[object String]\"\n}\n\n// Event assertions\nexport function isInputEvent(value: any): value is ChangeEvent {\n  return value && isObject(value) && isObject(value.target)\n}\n\n// Empty assertions\nexport const isEmpty = (value: any) => {\n  if (isArray(value)) return isEmptyArray(value)\n  if (isObject(value)) return isEmptyObject(value)\n  if (value == null || value === \"\") return true\n  return false\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const __DEV__ = process.env.NODE_ENV !== \"production\"\n","import { useCallback, useState } from \"react\"\n\ntype InitialState = boolean | (() => boolean)\n\n/**\n * React hook to manage boolean (on - off) states\n *\n * @param initialState the initial boolean state value\n */\nexport function useBoolean(initialState: InitialState = false) {\n  const [value, setValue] = useState(initialState)\n\n  const on = useCallback(() => {\n    setValue(true)\n  }, [])\n\n  const off = useCallback(() => {\n    setValue(false)\n  }, [])\n\n  const toggle = useCallback(() => {\n    setValue((prev) => !prev)\n  }, [])\n\n  return [value, { on, off, toggle }] as const\n}\n","import * as React from \"react\"\nimport { Booleanish, EventKeys } from \"./types\"\n\nexport function getOwnerWindow(node?: HTMLElement | null) {\n  return node instanceof Element\n    ? getOwnerDocument(node).defaultView ?? window\n    : window\n}\n\nexport function getOwnerDocument(node?: HTMLElement | null) {\n  return node instanceof Element ? node.ownerDocument ?? document : document\n}\n\nexport function canUseDOM() {\n  return !!(\n    typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport const isBrowser = canUseDOM()\n\n/**\n * Get the normalized event key across all browsers\n * @param event keyboard event\n */\nexport function normalizeEventKey(event: React.KeyboardEvent) {\n  const { key, keyCode } = event\n\n  const isArrowKey =\n    keyCode >= 37 && keyCode <= 40 && key.indexOf(\"Arrow\") !== 0\n\n  const eventKey = isArrowKey ? `Arrow${key}` : key\n\n  return eventKey as EventKeys\n}\n\nexport const dataAttr = (condition: boolean | undefined) =>\n  (condition ? \"\" : undefined) as Booleanish\n\nexport const ariaAttr = (condition: boolean | undefined) =>\n  condition ? true : undefined\n\nexport const cx = (...classNames: any[]) => classNames.filter(Boolean).join(\" \")\n\nexport function getActiveElement(node?: HTMLElement) {\n  const doc = getOwnerDocument(node)\n  return doc?.activeElement as HTMLElement\n}\n\nexport function contains(parent: HTMLElement, child: HTMLElement) {\n  return parent === child || parent.contains(child)\n}\n","import type { Dict, Omit } from \"./types\"\n\nexport { default as mergeWith } from \"lodash.mergewith\"\nexport { default as objectAssign } from \"object-assign\"\n\nexport function omit<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as K)) return\n    result[key] = object[key]\n  })\n\n  return result as Omit<T, K>\n}\n\nexport function pick<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result = {} as { [P in K]: T[P] }\n\n  keys.forEach((key) => {\n    if (key in object) {\n      result[key] = object[key]\n    }\n  })\n\n  return result\n}\n\nexport function split<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const picked: Dict = {}\n  const omitted: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as T[K])) {\n      picked[key] = object[key]\n    } else {\n      omitted[key] = object[key]\n    }\n  })\n\n  return [picked, omitted] as [{ [P in K]: T[P] }, Omit<T, K>]\n}\n\n/**\n * Get value from a deeply nested object using a string path.\n * Memoizes the value.\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\nexport function get(\n  obj: object,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) {\n  const key = typeof path === \"string\" ? path.split(\".\") : [path]\n\n  for (index = 0; index < key.length; index += 1) {\n    if (!obj) break\n    obj = obj[key[index]]\n  }\n\n  return obj === undefined ? fallback : obj\n}\n\ntype Get = (\n  obj: Readonly<object>,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) => any\n\nexport const memoize = (fn: Get) => {\n  const cache = new WeakMap()\n\n  const memoizedFn: Get = (obj, path, fallback, index) => {\n    if (typeof obj === \"undefined\") {\n      return fn(obj, path, fallback)\n    }\n\n    if (!cache.has(obj)) {\n      cache.set(obj, new Map())\n    }\n\n    const map = cache.get(obj)\n\n    if (map.has(path)) {\n      return map.get(path)\n    }\n\n    const value = fn(obj, path, fallback, index)\n\n    map.set(path, value)\n\n    return value\n  }\n\n  return memoizedFn\n}\n\nexport const memoizedGet = memoize(get)\n\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\nexport function getWithDefault(path: any, scale: any) {\n  return memoizedGet(scale, path, path)\n}\n\ntype FilterFn<T> = (value: any, key: string, object: T) => boolean\n\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\nexport function objectFilter<T extends Dict>(object: T, fn: FilterFn<T>) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    const value = object[key]\n    const shouldPass = fn(value, key, object)\n    if (shouldPass) {\n      result[key] = value\n    }\n  })\n\n  return result\n}\n\nexport const filterUndefined = (object: Dict) =>\n  objectFilter(object, (val) => val !== null && val !== undefined)\n\nexport const objectKeys = <T extends Dict>(obj: T) =>\n  (Object.keys(obj) as unknown) as (keyof T)[]\n\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\nexport const fromEntries = <T extends unknown>(entries: [string, any][]) =>\n  entries.reduce((carry, [key, value]) => {\n    carry[key] = value\n    return carry\n  }, {}) as T\n","import { isFunction, __DEV__ } from \"./assertion\"\nimport { AnyFunction, FunctionArguments } from \"./types\"\n\nexport function runIfFn<T, U>(\n  valueOrFn: T | ((...fnArgs: U[]) => T),\n  ...args: U[]\n): T {\n  return isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn\n}\n\nexport function callAllHandlers<T extends (event: any) => void>(\n  ...fns: (T | undefined)[]\n) {\n  return function func(event: FunctionArguments<T>[0]) {\n    fns.some((fn) => {\n      fn?.(event)\n      return event?.defaultPrevented\n    })\n  }\n}\n\nexport function callAll<T extends AnyFunction>(...fns: (T | undefined)[]) {\n  return function mergedFn(arg: FunctionArguments<T>[0]) {\n    fns.forEach((fn) => {\n      fn?.(arg)\n    })\n  }\n}\n\nexport const compose = <T>(\n  fn1: (...args: T[]) => T,\n  ...fns: Array<(...args: T[]) => T>\n) => fns.reduce((f1, f2) => (...args) => f1(f2(...args)), fn1)\n\nexport function once(fn?: Function | null) {\n  let result: any\n\n  return function func(this: any, ...args: any[]) {\n    if (fn) {\n      result = fn.apply(this, args)\n      fn = null\n    }\n\n    return result\n  }\n}\n\nexport const noop = () => {}\n\ntype MessageOptions = {\n  condition: boolean\n  message: string\n}\n\nexport const warn = once((options: MessageOptions) => {\n  const { condition, message } = options\n  if (condition && __DEV__) {\n    console.warn(message)\n  }\n})\n\nexport const error = once((options: MessageOptions) => {\n  const { condition, message } = options\n  if (condition && __DEV__) {\n    console.error(message)\n  }\n})\n","import { ariaAttr, callAllHandlers, omit } from \"@chakra-ui/utils\"\nimport { FocusEventHandler } from \"react\"\nimport { FormControlOptions, useFormControlContext } from \"./form-control\"\n\nexport interface UseFormControlProps<T extends HTMLElement>\n  extends FormControlOptions {\n  id?: string\n  onFocus?: FocusEventHandler<T>\n  onBlur?: FocusEventHandler<T>\n  disabled?: boolean\n  readOnly?: boolean\n  required?: boolean\n}\n\n/**\n * React hook that provides the props that should be spread on to\n * input fields (`input`, `select`, `textarea`, etc.).\n *\n * It provides a convenient way to control a form fields, validation\n * and helper text.\n */\nexport function useFormControl<T extends HTMLElement>(\n  props: UseFormControlProps<T>,\n) {\n  const field = useFormControlContext()\n  const describedBy: string[] = []\n\n  // Error message must be described first in all scenarios.\n  if (field?.hasFeedbackText) describedBy.push(field.feedbackId)\n  if (field?.hasHelpText) describedBy.push(field.helpTextId)\n  const ariaDescribedBy = describedBy.join(\" \")\n\n  const cleanProps = omit(props, [\n    \"isInvalid\",\n    \"isDisabled\",\n    \"isReadOnly\",\n    \"isRequired\",\n  ])\n\n  return {\n    ...cleanProps,\n    id: props.id ?? field?.id,\n    disabled: props.disabled || props.isDisabled || field?.isDisabled,\n    readOnly: props.readOnly || props.isReadOnly || field?.isReadOnly,\n    required: props.required || props.isRequired || field?.isRequired,\n    \"aria-invalid\": ariaAttr(props.isInvalid || field?.isInvalid),\n    \"aria-required\": ariaAttr(props.isRequired || field?.isRequired),\n    \"aria-readonly\": ariaAttr(props.isReadOnly || field?.isReadOnly),\n    \"aria-describedby\": ariaDescribedBy || undefined,\n    onFocus: callAllHandlers(field?.onFocus, props.onFocus),\n    onBlur: callAllHandlers(field?.onBlur, props.onBlur),\n  }\n}\n","import {\n  chakra,\n  forwardRef,\n  HTMLChakraProps,\n  omitThemingProps,\n  ThemingProps,\n  useStyleConfig,\n  useStyles,\n} from \"@chakra-ui/system\"\nimport { cx, dataAttr, Dict, __DEV__ } from \"@chakra-ui/utils\"\nimport * as React from \"react\"\nimport { useFormControlContext } from \"./form-control\"\n\nexport function useFieldLabel(props: Dict) {\n  const field = useFormControlContext()\n  return {\n    ...props,\n    \"data-focus\": dataAttr(field?.isFocused),\n    \"data-disabled\": dataAttr(field?.isDisabled),\n    \"data-invalid\": dataAttr(field?.isInvalid),\n    \"data-readonly\": dataAttr(field?.isReadOnly),\n    id: props.id ?? field?.labelId,\n    htmlFor: props.htmlFor ?? field?.id,\n  }\n}\n\nexport interface FormLabelProps extends HTMLChakraProps<\"label\">, ThemingProps {\n  /**\n   * @type React.ReactElement\n   */\n  requiredIndicator?: React.ReactElement\n}\n\n/**\n * Used to enhance the usability of form controls.\n *\n * It is used to inform users as to what information\n * is requested for a form field.\n *\n * ♿️ Accessibility: Every form field should have a form label.\n */\nexport const FormLabel = forwardRef<FormLabelProps, \"label\">(\n  (passedProps, ref) => {\n    const styles = useStyleConfig(\"FormLabel\", passedProps)\n    const props = omitThemingProps(passedProps)\n\n    const {\n      className,\n      children,\n      requiredIndicator = <RequiredIndicator />,\n      ...rest\n    } = props\n\n    const ownProps = useFieldLabel(rest)\n    const field = useFormControlContext()\n\n    return (\n      <chakra.label\n        ref={ref}\n        className={cx(\"chakra-form__label\", props.className)}\n        __css={{\n          display: \"block\",\n          textAlign: \"start\",\n          ...styles,\n        }}\n        {...ownProps}\n      >\n        {children}\n        {field?.isRequired ? requiredIndicator : null}\n      </chakra.label>\n    )\n  },\n)\n\nif (__DEV__) {\n  FormLabel.displayName = \"FormLabel\"\n}\n\nexport interface RequiredIndicatorProps extends HTMLChakraProps<\"span\"> {}\n\n/**\n * Used to show a \"required\" text or an asterisks (*) to indicate that\n * a field is required.\n */\nexport const RequiredIndicator = forwardRef<RequiredIndicatorProps, \"span\">(\n  (props, ref) => {\n    const { children, className, ...rest } = props\n    const field = useFormControlContext()\n    const styles = useStyles()\n\n    if (!field?.isRequired) return null\n\n    const _className = cx(\"chakra-form__required-indicator\", className)\n\n    return (\n      <chakra.span\n        role=\"presentation\"\n        aria-hidden\n        ref={ref}\n        {...rest}\n        __css={styles.requiredIndicator}\n        className={_className}\n      >\n        {children || \"*\"}\n      </chakra.span>\n    )\n  },\n)\n\nif (__DEV__) {\n  RequiredIndicator.displayName = \"RequiredIndicator\"\n}\n","import {\n  chakra,\n  ChakraProps,\n  forwardRef,\n  SystemStyleObject,\n} from \"@chakra-ui/system\"\nimport { cx, __DEV__ } from \"@chakra-ui/utils\"\nimport * as React from \"react\"\n\nconst fallbackIcon = {\n  path: (\n    <g stroke=\"currentColor\" strokeWidth=\"1.5\">\n      <path\n        strokeLinecap=\"round\"\n        fill=\"none\"\n        d=\"M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25\"\n      />\n      <path\n        fill=\"currentColor\"\n        strokeLinecap=\"round\"\n        d=\"M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0\"\n      />\n      <circle fill=\"none\" strokeMiterlimit=\"10\" cx=\"12\" cy=\"12\" r=\"11.25\" />\n    </g>\n  ),\n  viewBox: \"0 0 24 24\",\n}\n\nexport interface IconProps\n  extends Omit<React.SVGAttributes<SVGElement>, keyof ChakraProps>,\n    ChakraProps {}\n\nexport const Icon = forwardRef<IconProps, \"svg\">((props, ref) => {\n  const {\n    as: element,\n    viewBox,\n    color = \"currentColor\",\n    focusable = false,\n    children,\n    className,\n    __css,\n    ...rest\n  } = props\n\n  const _className = cx(\"chakra-icon\", className)\n\n  const styles: SystemStyleObject = {\n    w: \"1em\",\n    h: \"1em\",\n    display: \"inline-block\",\n    lineHeight: \"1em\",\n    flexShrink: 0,\n    color,\n    ...__css,\n  }\n\n  const shared: any = {\n    ref,\n    focusable,\n    className: _className,\n    __css: styles,\n  }\n\n  const _viewBox = viewBox ?? fallbackIcon.viewBox\n\n  /**\n   * If you're using an icon library like `react-icons`.\n   * Note: anyone passing the `as` prop, should manage the `viewBox` from the external component\n   */\n  if (element && typeof element !== \"string\") {\n    return <chakra.svg as={element} {...shared} {...rest} />\n  }\n\n  const _path = (children ?? fallbackIcon.path) as React.ReactNode\n\n  return (\n    <chakra.svg verticalAlign=\"middle\" viewBox={_viewBox} {...shared} {...rest}>\n      {_path}\n    </chakra.svg>\n  )\n})\n\nif (__DEV__) {\n  Icon.displayName = \"Icon\"\n}\n\nexport default Icon\n","import { useSafeLayoutEffect } from \"@chakra-ui/hooks\"\nimport Icon, { IconProps } from \"@chakra-ui/icon\"\nimport {\n  chakra,\n  forwardRef,\n  useStyles,\n  HTMLChakraProps,\n  useMultiStyleConfig,\n  ThemingProps,\n  omitThemingProps,\n  StylesProvider,\n} from \"@chakra-ui/system\"\nimport { cx, __DEV__ } from \"@chakra-ui/utils\"\nimport * as React from \"react\"\nimport { useFormControlContext } from \"./form-control\"\n\nexport interface FormErrorMessageProps\n  extends HTMLChakraProps<\"div\">,\n    ThemingProps {}\n\n/**\n * Used to provide feedback about an invalid input,\n * and suggest clear instrctions on how to fix it.\n */\nexport const FormErrorMessage = forwardRef<FormErrorMessageProps, \"div\">(\n  (passedProps, ref) => {\n    const styles = useMultiStyleConfig(\"FormError\", passedProps)\n    const props = omitThemingProps(passedProps)\n\n    const field = useFormControlContext()\n\n    /**\n     * Notify the field context when the error message is rendered on screen,\n     * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).\n     */\n    useSafeLayoutEffect(() => {\n      field?.setHasFeedbackText.on()\n      return () => field?.setHasFeedbackText.off()\n    }, [])\n\n    if (!field?.isInvalid) return null\n\n    const _className = cx(\"chakra-form__error-message\", props.className)\n\n    return (\n      <StylesProvider value={styles}>\n        <chakra.div\n          aria-live=\"polite\"\n          ref={ref}\n          {...props}\n          __css={{\n            display: \"flex\",\n            alignItems: \"center\",\n            ...styles.text,\n          }}\n          className={_className}\n          id={props.id ?? field?.feedbackId}\n        />\n      </StylesProvider>\n    )\n  },\n)\n\nif (__DEV__) {\n  FormErrorMessage.displayName = \"FormErrorMessage\"\n}\n\n/**\n * Used as the visual indicator that a field is invalid or\n * a field has incorrect values.\n */\nexport const FormErrorIcon = forwardRef<IconProps, \"svg\">((props, ref) => {\n  const styles = useStyles()\n  const field = useFormControlContext()\n\n  if (!field?.isInvalid) return null\n\n  const _className = cx(\"chakra-form__error-icon\", props.className)\n\n  return (\n    <Icon\n      ref={ref}\n      aria-hidden\n      {...props}\n      __css={styles.icon}\n      className={_className}\n    >\n      <path\n        fill=\"currentColor\"\n        d=\"M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z\"\n      />\n    </Icon>\n  )\n})\n\nif (__DEV__) {\n  FormErrorIcon.displayName = \"FormErrorIcon\"\n}\n","import { FormControlOptions, useFormControl } from \"@chakra-ui/form-control\"\nimport {\n  chakra,\n  forwardRef,\n  omitThemingProps,\n  ThemingProps,\n  useMultiStyleConfig,\n  HTMLChakraProps,\n} from \"@chakra-ui/system\"\nimport { cx, __DEV__ } from \"@chakra-ui/utils\"\nimport * as React from \"react\"\n\ninterface InputOptions {\n  /**\n   * The border color when the input is focused. Use color keys in `theme.colors`\n   * @example\n   * focusBorderColor = \"blue.500\"\n   */\n  focusBorderColor?: string\n  /**\n   * The border color when the input is invalid. Use color keys in `theme.colors`\n   * @example\n   * errorBorderColor = \"red.500\"\n   */\n  errorBorderColor?: string\n  /**\n   * If `true`, the input element will span the full width of its parent\n   *\n   * @deprecated\n   * This component defaults to 100% width,\n   *  please use the props `maxWidth` or `width` to configure\n   */\n  isFullWidth?: boolean\n}\n\ntype Omitted = \"disabled\" | \"required\" | \"readOnly\" | \"size\"\n\nexport interface InputProps\n  extends Omit<HTMLChakraProps<\"input\">, Omitted>,\n    InputOptions,\n    ThemingProps,\n    FormControlOptions {\n  size?: string\n}\n\n/**\n * Input\n *\n * Element that allows users enter single valued data.\n */\nexport const Input = forwardRef<InputProps, \"input\">((props, ref) => {\n  const styles = useMultiStyleConfig(\"Input\", props)\n  const ownProps = omitThemingProps(props)\n  const input = useFormControl<HTMLInputElement>(ownProps)\n  const _className = cx(\"chakra-input\", props.className)\n\n  return (\n    <chakra.input\n      {...input}\n      __css={styles.field}\n      ref={ref}\n      className={_className}\n    />\n  )\n})\n\nif (__DEV__) {\n  Input.displayName = \"Input\"\n}\n\n// This is used in `input-group.tsx`\nInput.id = \"Input\"\n"],"sourceRoot":""}