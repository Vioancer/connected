{"version":3,"sources":["../../../src/Edit.tsx","../../../src/SmallAdd.tsx","../../../src/object.ts","../../../src/dom.ts","../../../src/assertion.ts","../../../src/react-helpers.ts","../../../src/function.ts","../../../src/use-tabs.ts","../../../src/tabs.tsx"],"names":["EditIcon","createIcon","displayName","path","fill","stroke","strokeLinecap","strokeWidth","d","SmallAddIcon","viewBox","fillRule","fn","cache","memoize","key","index","obj","window","cx","classNames","isFunction","value","isUndefined","__DEV__","process","assignRef","ref","error","Error","mergeRefs","refs","callAllHandlers","fns","event","once","args","result","options","message","strict","errorMessage","name","Context","React","context","createContext","useTabPanels","useTabsContext","selectedIndex","children","child","getValidChildren","props","isSelected","id","makeTabPanelId","makeTabId","Tabs","forwardRef","styles","useMultiStyleConfig","omitThemingProps","className","orientation","defaultIndex","useControllableState","defaultValue","onChange","propsMap","setFocusedIndex","enabledDomContext","useDescendants","domContext","useId","focusedIndex","setSelectedIndex","isManual","isLazy","htmlProps","useTabs","rootProps","Object","keys","object","omit","__css","root","Tab","useStyles","tabProps","isFocusable","enabledIndex","useDescendant","disabled","Boolean","focusable","element","current","clickableProps","useClickable","isDisabled","onClick","role","tabIndex","type","onFocus","undefined","useTab","tabStyles","outline","display","alignItems","justifyContent","TabList","tablistProps","count","setIndex","tab","onKeyDown","nextTab","prevTab","isHorizontal","isVertical","action","ArrowRight","ArrowLeft","ArrowDown","ArrowUp","Home","End","keyCode","normalizeEventKey","useTabList","tablistStyles","TabPanel","panelProps","hidden","useTabPanel","tabpanel","TabPanels","panelsProps","width"],"mappings":"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","file":"static/js/10.80d236d1.chunk.js","sourcesContent":["import { createIcon } from \"@chakra-ui/icon\"\nimport * as React from \"react\"\n\nexport const EditIcon = createIcon({\n  displayName: \"EditIcon\",\n  path: (\n    <g fill=\"none\" stroke=\"currentColor\" strokeLinecap=\"round\" strokeWidth=\"2\">\n      <path d=\"M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7\" />\n      <path d=\"M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z\" />\n    </g>\n  ),\n})\n","import { createIcon } from \"@chakra-ui/icon\"\nimport * as React from \"react\"\n\nexport const SmallAddIcon = createIcon({\n  displayName: \"SmallAddIcon\",\n  viewBox: \"0 0 20 20\",\n  path: (\n    <path\n      fill=\"currentColor\"\n      d=\"M14 9h-3V6c0-.55-.45-1-1-1s-1 .45-1 1v3H6c-.55 0-1 .45-1 1s.45 1 1 1h3v3c0 .55.45 1 1 1s1-.45 1-1v-3h3c.55 0 1-.45 1-1s-.45-1-1-1z\"\n      fillRule=\"evenodd\"\n    />\n  ),\n})\n","import type { Dict, Omit } from \"./types\"\n\nexport { default as mergeWith } from \"lodash.mergewith\"\nexport { default as objectAssign } from \"object-assign\"\n\nexport function omit<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as K)) return\n    result[key] = object[key]\n  })\n\n  return result as Omit<T, K>\n}\n\nexport function pick<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const result = {} as { [P in K]: T[P] }\n\n  keys.forEach((key) => {\n    if (key in object) {\n      result[key] = object[key]\n    }\n  })\n\n  return result\n}\n\nexport function split<T extends Dict, K extends keyof T>(object: T, keys: K[]) {\n  const picked: Dict = {}\n  const omitted: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    if (keys.includes(key as T[K])) {\n      picked[key] = object[key]\n    } else {\n      omitted[key] = object[key]\n    }\n  })\n\n  return [picked, omitted] as [{ [P in K]: T[P] }, Omit<T, K>]\n}\n\n/**\n * Get value from a deeply nested object using a string path.\n * Memoizes the value.\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\nexport function get(\n  obj: object,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) {\n  const key = typeof path === \"string\" ? path.split(\".\") : [path]\n\n  for (index = 0; index < key.length; index += 1) {\n    if (!obj) break\n    obj = obj[key[index]]\n  }\n\n  return obj === undefined ? fallback : obj\n}\n\ntype Get = (\n  obj: Readonly<object>,\n  path: string | number,\n  fallback?: any,\n  index?: number,\n) => any\n\nexport const memoize = (fn: Get) => {\n  const cache = new WeakMap()\n\n  const memoizedFn: Get = (obj, path, fallback, index) => {\n    if (typeof obj === \"undefined\") {\n      return fn(obj, path, fallback)\n    }\n\n    if (!cache.has(obj)) {\n      cache.set(obj, new Map())\n    }\n\n    const map = cache.get(obj)\n\n    if (map.has(path)) {\n      return map.get(path)\n    }\n\n    const value = fn(obj, path, fallback, index)\n\n    map.set(path, value)\n\n    return value\n  }\n\n  return memoizedFn\n}\n\nexport const memoizedGet = memoize(get)\n\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\nexport function getWithDefault(path: any, scale: any) {\n  return memoizedGet(scale, path, path)\n}\n\ntype FilterFn<T> = (value: any, key: string, object: T) => boolean\n\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\nexport function objectFilter<T extends Dict>(object: T, fn: FilterFn<T>) {\n  const result: Dict = {}\n\n  Object.keys(object).forEach((key) => {\n    const value = object[key]\n    const shouldPass = fn(value, key, object)\n    if (shouldPass) {\n      result[key] = value\n    }\n  })\n\n  return result\n}\n\nexport const filterUndefined = (object: Dict) =>\n  objectFilter(object, (val) => val !== null && val !== undefined)\n\nexport const objectKeys = <T extends Dict>(obj: T) =>\n  (Object.keys(obj) as unknown) as (keyof T)[]\n\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\nexport const fromEntries = <T extends unknown>(entries: [string, any][]) =>\n  entries.reduce((carry, [key, value]) => {\n    carry[key] = value\n    return carry\n  }, {}) as T\n","import * as React from \"react\"\nimport { Booleanish, EventKeys } from \"./types\"\n\nexport function getOwnerWindow(node?: HTMLElement | null) {\n  return node instanceof Element\n    ? getOwnerDocument(node).defaultView ?? window\n    : window\n}\n\nexport function getOwnerDocument(node?: HTMLElement | null) {\n  return node instanceof Element ? node.ownerDocument ?? document : document\n}\n\nexport function canUseDOM() {\n  return !!(\n    typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport const isBrowser = canUseDOM()\n\n/**\n * Get the normalized event key across all browsers\n * @param event keyboard event\n */\nexport function normalizeEventKey(event: React.KeyboardEvent) {\n  const { key, keyCode } = event\n\n  const isArrowKey =\n    keyCode >= 37 && keyCode <= 40 && key.indexOf(\"Arrow\") !== 0\n\n  const eventKey = isArrowKey ? `Arrow${key}` : key\n\n  return eventKey as EventKeys\n}\n\nexport const dataAttr = (condition: boolean | undefined) =>\n  (condition ? \"\" : undefined) as Booleanish\n\nexport const ariaAttr = (condition: boolean | undefined) =>\n  condition ? true : undefined\n\nexport const cx = (...classNames: any[]) => classNames.filter(Boolean).join(\" \")\n\nexport function getActiveElement(node?: HTMLElement) {\n  const doc = getOwnerDocument(node)\n  return doc?.activeElement as HTMLElement\n}\n\nexport function contains(parent: HTMLElement, child: HTMLElement) {\n  return parent === child || parent.contains(child)\n}\n","import { ChangeEvent } from \"react\"\nimport { Dict } from \"./types\"\n\n// Number assertions\nexport function isNumber(value: any): value is number {\n  return typeof value === \"number\"\n}\n\nexport const isNotNumber = (value: any) =>\n  typeof value !== \"number\" || Number.isNaN(value) || !Number.isFinite(value)\n\nexport function isNumeric(value: any) {\n  return value != null && value - parseFloat(value) + 1 >= 0\n}\n\n// Array assertions\nexport function isArray<T>(value: any): value is Array<T> {\n  return Array.isArray(value)\n}\n\nexport const isEmptyArray = (value: any) => isArray(value) && value.length === 0\n\n// Function assertions\nexport function isFunction(value: any): value is Function {\n  return typeof value === \"function\"\n}\n\n// Generic assertions\nexport const isDefined = (value: any) =>\n  typeof value !== \"undefined\" && value !== undefined\n\nexport const isUndefined = (value: any): value is undefined =>\n  typeof value === \"undefined\" || value === undefined\n\n// Object assertions\nexport const isObject = (value: any): value is Dict => {\n  const type = typeof value\n  return (\n    value != null &&\n    (type === \"object\" || type === \"function\") &&\n    !isArray(value)\n  )\n}\n\nexport const isEmptyObject = (value: any) =>\n  isObject(value) && Object.keys(value).length === 0\n\nexport function isNotEmptyObject(value: any): value is object {\n  return value && !isEmptyObject(value)\n}\n\nexport const isNull = (value: any): value is null => value == null\n\n// String assertions\nexport function isString(value: any): value is string {\n  return Object.prototype.toString.call(value) === \"[object String]\"\n}\n\n// Event assertions\nexport function isInputEvent(value: any): value is ChangeEvent {\n  return value && isObject(value) && isObject(value.target)\n}\n\n// Empty assertions\nexport const isEmpty = (value: any) => {\n  if (isArray(value)) return isEmptyArray(value)\n  if (isObject(value)) return isEmptyObject(value)\n  if (value == null || value === \"\") return true\n  return false\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const __DEV__ = process.env.NODE_ENV !== \"production\"\n","import * as React from \"react\"\nimport { isFunction } from \"./assertion\"\n\nexport interface CreateContextOptions {\n  /**\n   * If `true`, React will throw if context is `null` or `undefined`\n   * In some cases, you might want to support nested context, so you can set it to `false`\n   */\n  strict?: boolean\n  /**\n   * Error message to throw if the context is `undefined`\n   */\n  errorMessage?: string\n  /**\n   * The display name of the context\n   */\n  name?: string\n}\n\ntype CreateContextReturn<T> = [React.Provider<T>, () => T, React.Context<T>]\n\n/**\n * Creates a named context, provider, and hook.\n *\n * @param options create context options\n */\nexport function createContext<ContextType>(options: CreateContextOptions = {}) {\n  const {\n    strict = true,\n    errorMessage = \"useContext: `context` is undefined. Seems you forgot to wrap component within the Provider\",\n    name,\n  } = options\n\n  const Context = React.createContext<ContextType | undefined>(undefined)\n\n  Context.displayName = name\n\n  function useContext() {\n    const context = React.useContext(Context)\n\n    if (!context && strict) {\n      throw new Error(errorMessage)\n    }\n\n    return context\n  }\n\n  return [\n    Context.Provider,\n    useContext,\n    Context,\n  ] as CreateContextReturn<ContextType>\n}\n\n/**\n * Gets only the valid children of a component,\n * and ignores any nullish or falsy child.\n *\n * @param children the children\n */\nexport function getValidChildren(children: React.ReactNode) {\n  return React.Children.toArray(children).filter((child) =>\n    React.isValidElement(child),\n  ) as React.ReactElement[]\n}\n\ntype ReactRef<T> = React.Ref<T> | React.RefObject<T> | React.MutableRefObject<T>\n\n/**\n * Assigns a value to a ref function or object\n *\n * @param ref the ref to assign to\n * @param value the value\n */\nexport function assignRef<T = any>(ref: ReactRef<T> | undefined, value: T) {\n  if (ref == null) return\n\n  if (isFunction(ref)) {\n    ref(value)\n    return\n  }\n\n  try {\n    // @ts-ignore\n    ref.current = value\n  } catch (error) {\n    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`)\n  }\n}\n\n/**\n * Combine multiple React refs into a single ref function.\n * This is used mostly when you need to allow consumers forward refs to\n * internal components\n *\n * @param refs refs to assign to value to\n */\nexport function mergeRefs<T>(...refs: (ReactRef<T> | undefined)[]) {\n  return (value: T) => {\n    refs.forEach((ref) => assignRef(ref, value))\n  }\n}\n","import { isFunction, __DEV__ } from \"./assertion\"\nimport { AnyFunction, FunctionArguments } from \"./types\"\n\nexport function runIfFn<T, U>(\n  valueOrFn: T | ((...fnArgs: U[]) => T),\n  ...args: U[]\n): T {\n  return isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn\n}\n\nexport function callAllHandlers<T extends (event: any) => void>(\n  ...fns: (T | undefined)[]\n) {\n  return function func(event: FunctionArguments<T>[0]) {\n    fns.some((fn) => {\n      fn?.(event)\n      return event?.defaultPrevented\n    })\n  }\n}\n\nexport function callAll<T extends AnyFunction>(...fns: (T | undefined)[]) {\n  return function mergedFn(arg: FunctionArguments<T>[0]) {\n    fns.forEach((fn) => {\n      fn?.(arg)\n    })\n  }\n}\n\nexport const compose = <T>(\n  fn1: (...args: T[]) => T,\n  ...fns: Array<(...args: T[]) => T>\n) => fns.reduce((f1, f2) => (...args) => f1(f2(...args)), fn1)\n\nexport function once(fn?: Function | null) {\n  let result: any\n\n  return function func(this: any, ...args: any[]) {\n    if (fn) {\n      result = fn.apply(this, args)\n      fn = null\n    }\n\n    return result\n  }\n}\n\nexport const noop = () => {}\n\ntype MessageOptions = {\n  condition: boolean\n  message: string\n}\n\nexport const warn = once((options: MessageOptions) => {\n  const { condition, message } = options\n  if (condition && __DEV__) {\n    console.warn(message)\n  }\n})\n\nexport const error = once((options: MessageOptions) => {\n  const { condition, message } = options\n  if (condition && __DEV__) {\n    console.error(message)\n  }\n})\n","import { useClickable, UseClickableProps } from \"@chakra-ui/clickable\"\nimport { useDescendant, useDescendants } from \"@chakra-ui/descendant\"\nimport {\n  useControllableState,\n  useId,\n  useSafeLayoutEffect,\n} from \"@chakra-ui/hooks\"\nimport {\n  callAllHandlers,\n  createContext,\n  Dict,\n  EventKeyMap,\n  getValidChildren,\n  isUndefined,\n  mergeRefs,\n  normalizeEventKey,\n} from \"@chakra-ui/utils\"\nimport * as React from \"react\"\n\nexport interface UseTabsProps {\n  /**\n   * The orientation of the tab list.\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * If `true`, the tabs will be manually activated and\n   * display its panel by pressing Space or Enter.\n   *\n   * If `false`, the tabs will be automatically activated\n   * and their panel is displayed when they receive focus.\n   */\n  isManual?: boolean\n  /**\n   * Callback when the index (controlled or un-controlled) changes.\n   */\n  onChange?: (index: number) => void\n  /**\n   * The index of the selected tab (in controlled mode)\n   */\n  index?: number\n  /**\n   * The initial index of the selected tab (in uncontrolled mode)\n   */\n  defaultIndex?: number\n  /**\n   * The id of the tab\n   */\n  id?: string\n  /**\n   * Performance 🚀:\n   * If `true`, the TabPanel rendering will be deferred\n   * until it is open.\n   */\n  isLazy?: boolean\n}\n\n/**\n * Tabs hooks that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * Its returned object will be passed unto a Context Provider\n * so all child components can read from it.\n * There is no document link yet\n * @see Docs https://chakra-ui.com/docs/components/useTabs\n */\nexport function useTabs(props: UseTabsProps) {\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    orientation = \"horizontal\",\n    ...htmlProps\n  } = props\n\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n  const [focusedIndex, setFocusedIndex] = React.useState(defaultIndex ?? 0)\n\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex ?? 0,\n    value: index,\n    onChange,\n    propsMap: {\n      value: \"index\",\n      defaultValue: \"defaultIndex\",\n      onChange: \"onChange\",\n    },\n  })\n\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n  React.useEffect(() => {\n    if (!isUndefined(index)) {\n      setFocusedIndex(index)\n    }\n  }, [index])\n\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   *\n   * This manager is used to store only the tab nodes that are not disabled, and focusable.\n   * If we have the following code\n   *\n   * ```jsx\n   * <Tab>Tab 1</Tab>\n   * <Tab isDisabled>Tab 2</Tab>\n   * <Tab>Tab 3</Tab>\n   * ```\n   *\n   * The manager will only hold references to \"Tab 1\" and \"Tab 3\", since `Tab 2` is disabled\n   */\n  const enabledDomContext = useDescendants()\n\n  /**\n   * This manager is used to store all tab nodes whether disabled or not.\n   * If we have the following code\n   *\n   * ```jsx\n   * <Tab>Tab 1</Tab>\n   * <Tab isDisabled>Tab 2</Tab>\n   * <Tab>Tab 3</Tab>\n   * ```\n   *\n   * The manager will only hold references to \"Tab 1\", \"Tab 2\" \"Tab 3\".\n   *\n   * We need this for correct indexing of tabs in event a tab is disabled\n   */\n  const domContext = useDescendants()\n\n  /**\n   * generate a unique id or use user-provided id for\n   * the tabs widget\n   */\n  const id = useId(props.id, `tabs`)\n\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    orientation,\n    enabledDomContext,\n    domContext,\n    htmlProps,\n  }\n}\n\nexport type UseTabsReturn = Omit<ReturnType<typeof useTabs>, \"htmlProps\">\n\nconst [TabsProvider, useTabsContext] = createContext<UseTabsReturn>({\n  name: \"TabsContext\",\n  errorMessage:\n    \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\",\n})\n\nexport { TabsProvider }\n\ntype Child = React.ReactElement<any>\n\nexport interface UseTabListProps {\n  children?: React.ReactNode\n  onKeyDown?: React.KeyboardEventHandler\n  ref?: React.Ref<any>\n}\n\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\nexport function useTabList<P extends UseTabListProps>(props: P) {\n  const {\n    setFocusedIndex,\n    focusedIndex,\n    orientation,\n    enabledDomContext,\n  } = useTabsContext()\n\n  const count = enabledDomContext.descendants.length\n\n  /**\n   * Function to update the selected tab index\n   */\n  const setIndex = React.useCallback(\n    (index: number) => {\n      const tab = enabledDomContext.descendants[index]\n      if (tab?.element) {\n        tab.element.focus()\n        setFocusedIndex(index)\n      }\n    },\n    [enabledDomContext.descendants, setFocusedIndex],\n  )\n\n  const onKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      const nextTab = () => setIndex((focusedIndex + 1) % count)\n      const prevTab = () => setIndex((focusedIndex - 1 + count) % count)\n      const firstTab = () => setIndex(0)\n      const lastTab = () => setIndex(count - 1)\n\n      const isHorizontal = orientation === \"horizontal\"\n      const isVertical = orientation === \"vertical\"\n\n      const eventKey = normalizeEventKey(event)\n      const keyMap: EventKeyMap = {\n        ArrowRight: () => isHorizontal && nextTab(),\n        ArrowLeft: () => isHorizontal && prevTab(),\n        ArrowDown: () => isVertical && nextTab(),\n        ArrowUp: () => isVertical && prevTab(),\n        Home: firstTab,\n        End: lastTab,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [count, focusedIndex, orientation, setIndex],\n  )\n\n  return {\n    ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\nexport type UseTabListReturn = ReturnType<typeof useTabList>\n\nexport interface UseTabOptions {\n  id?: string\n  isSelected?: boolean\n  panelId?: string\n  /**\n   * If `true`, the `Tab` won't be toggleable\n   */\n  isDisabled?: boolean\n}\n\nexport interface UseTabProps\n  extends Omit<UseClickableProps, \"color\">,\n    UseTabOptions {}\n\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\nexport function useTab<P extends UseTabProps>(props: P) {\n  const { isDisabled, isFocusable, ...htmlProps } = props\n\n  const {\n    setSelectedIndex,\n    isManual,\n    id,\n    setFocusedIndex,\n    enabledDomContext,\n    domContext,\n    selectedIndex,\n  } = useTabsContext()\n\n  const ref = React.useRef<HTMLElement>(null)\n\n  /**\n   * Think of `useDescendant` as the function that registers tab node\n   * to the `enabledDomContext`, and returns its index.\n   *\n   * Tab is registered if it is enabled or focusable\n   */\n  const enabledIndex = useDescendant({\n    disabled: Boolean(isDisabled),\n    focusable: Boolean(isFocusable),\n    context: enabledDomContext,\n    element: ref.current,\n  })\n\n  /**\n   * Registers all tabs (whether disabled or not)\n   */\n  const index = useDescendant({\n    context: domContext,\n    element: ref.current,\n  })\n\n  const isSelected = index === selectedIndex\n\n  const onClick = () => {\n    setFocusedIndex(enabledIndex)\n    setSelectedIndex(index)\n  }\n\n  const onFocus = () => {\n    const isDisabledButFocusable = isDisabled && isFocusable\n    const shouldSelect = !isManual && !isDisabledButFocusable\n\n    if (shouldSelect) {\n      setSelectedIndex(index)\n    }\n  }\n\n  const clickableProps = useClickable({\n    ...htmlProps,\n    ref: mergeRefs(ref, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick),\n  })\n\n  const type: \"button\" | \"submit\" | \"reset\" = \"button\"\n\n  return {\n    ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus),\n  }\n}\n\nexport interface UseTabPanelsProps {\n  children?: React.ReactNode\n}\n\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of its children with\n * all functionality included.\n */\nexport function useTabPanels<P extends UseTabPanelsProps>(props: P) {\n  const context = useTabsContext()\n\n  const { id, selectedIndex } = context\n\n  const validChildren = getValidChildren(props.children)\n\n  const children = validChildren.map((child, index) =>\n    React.cloneElement(child as Child, {\n      isSelected: index === selectedIndex,\n      id: makeTabPanelId(id, index),\n      /**\n       * Refers to the associated tab element, and also provides an accessible name to the tab panel.\n       */\n      \"aria-labelledby\": makeTabId(id, index),\n    }),\n  )\n\n  return { ...props, children }\n}\n\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\nexport function useTabPanel(props: Dict) {\n  const { isSelected, id, children, ...htmlProps } = props\n  const { isLazy } = useTabsContext()\n\n  return {\n    /**\n     * Puts the tabpanel in the page `Tab` sequence.\n     */\n    tabIndex: 0,\n    ...htmlProps,\n    children: !isLazy || isSelected ? children : null,\n    role: \"tabpanel\",\n    hidden: !isSelected,\n    id,\n  }\n}\n\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\nexport function useTabIndicator(): React.CSSProperties {\n  const context = useTabsContext()\n\n  const { selectedIndex, orientation, domContext } = context\n\n  const isHorizontal = orientation === \"horizontal\"\n  const isVertical = orientation === \"vertical\"\n\n  // Get the clientRect of the selected tab\n  const [rect, setRect] = React.useState(() => {\n    if (isHorizontal) return { left: 0, width: 0 }\n    if (isVertical) return { top: 0, height: 0 }\n    return undefined\n  })\n\n  const [hasMeasured, setHasMeasured] = React.useState(false)\n\n  // Update the selected tab rect when the selectedIndex changes\n  useSafeLayoutEffect(() => {\n    if (isUndefined(selectedIndex)) return undefined\n\n    const tab = domContext.descendants[selectedIndex]\n    const tabRect = tab?.element?.getBoundingClientRect()\n\n    // Horizontal Tab: Calculate width and left distance\n    if (isHorizontal && tabRect) {\n      const { left, width } = tabRect\n      setRect({ left, width })\n    }\n\n    // Vertical Tab: Calculate height and top distance\n    if (isVertical && tabRect) {\n      const { top, height } = tabRect\n      setRect({ top, height })\n    }\n\n    // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true)\n    })\n\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id)\n      }\n    }\n  }, [selectedIndex, isHorizontal, isVertical, domContext.descendants])\n\n  return {\n    position: \"absolute\",\n    transition: hasMeasured ? \"all 200ms cubic-bezier(0, 0, 0.2, 1)\" : \"none\",\n    ...rect,\n  }\n}\n\nfunction makeTabId(id: string, index: number) {\n  return `${id}--tab-${index}`\n}\n\nfunction makeTabPanelId(id: string, index: number) {\n  return `${id}--tabpanel-${index}`\n}\n","import {\n  chakra,\n  forwardRef,\n  omitThemingProps,\n  StylesProvider,\n  SystemStyleObject,\n  ThemingProps,\n  useMultiStyleConfig,\n  useStyles,\n  HTMLChakraProps,\n} from \"@chakra-ui/system\"\nimport { cx, omit, __DEV__ } from \"@chakra-ui/utils\"\nimport * as React from \"react\"\nimport {\n  TabsProvider,\n  useTab,\n  useTabIndicator,\n  useTabList,\n  UseTabListProps,\n  UseTabOptions,\n  useTabPanel,\n  useTabPanels,\n  useTabs,\n  UseTabsProps,\n} from \"./use-tabs\"\n\ninterface TabsOptions {\n  /**\n   * If `true`, tabs will stretch to width of the tablist.\n   */\n  isFitted?: boolean\n  /**\n   * The alignment of the tabs\n   */\n  align?: \"start\" | \"end\" | \"center\"\n}\n\nexport interface TabsProps\n  extends UseTabsProps,\n    ThemingProps,\n    Omit<HTMLChakraProps<\"div\">, \"onChange\">,\n    TabsOptions {\n  children: React.ReactNode\n}\n\n/**\n * Tabs\n *\n * Provides context and logic for all tabs components. It doesn't render\n * any DOM node.\n */\nexport const Tabs = forwardRef<TabsProps, \"div\">((props, ref) => {\n  const styles = useMultiStyleConfig(\"Tabs\", props)\n  const { children, className, ...rest } = omitThemingProps(props)\n\n  const { htmlProps, ...ctx } = useTabs(rest)\n  const context = React.useMemo(() => ctx, [ctx])\n\n  const rootProps = omit(htmlProps as any, [\"isFitted\"])\n\n  return (\n    <TabsProvider value={context}>\n      <StylesProvider value={styles}>\n        <chakra.div\n          className={cx(\"chakra-tabs\", className)}\n          ref={ref}\n          {...rootProps}\n          __css={styles.root}\n        >\n          {children}\n        </chakra.div>\n      </StylesProvider>\n    </TabsProvider>\n  )\n})\n\nif (__DEV__) {\n  Tabs.displayName = \"Tabs\"\n}\n\nexport interface TabProps extends UseTabOptions, HTMLChakraProps<\"button\"> {}\n\n/**\n * Tab button used to activate a specific tab panel. It renders a `button`,\n * and is responsible for automatic and manual selection modes.\n */\nexport const Tab = forwardRef<TabProps, \"button\">((props, ref) => {\n  const styles = useStyles()\n  const tabProps = useTab({ ...props, ref })\n\n  const tabStyles: SystemStyleObject = {\n    outline: \"0\",\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    ...styles.tab,\n  }\n\n  return (\n    <chakra.button\n      {...tabProps}\n      className={cx(\"chakra-tabs__tab\", props.className)}\n      __css={tabStyles}\n    />\n  )\n})\n\nif (__DEV__) {\n  Tab.displayName = \"Tab\"\n}\n\nexport interface TabListProps\n  extends UseTabListProps,\n    Omit<HTMLChakraProps<\"div\">, \"onKeyDown\" | \"ref\"> {}\n\n/**\n * TabList is used to manage a list of tab buttons. It renders a `div` by default,\n * and is responsible the keyboard interaction between tabs.\n */\nexport const TabList = forwardRef<TabListProps, \"div\">((props, ref) => {\n  const tablistProps = useTabList({ ...props, ref })\n\n  const styles = useStyles()\n\n  const tablistStyles: SystemStyleObject = {\n    display: \"flex\",\n    ...styles.tablist,\n  }\n\n  return (\n    <chakra.div\n      {...tablistProps}\n      className={cx(\"chakra-tabs__tablist\", props.className)}\n      __css={tablistStyles}\n    />\n  )\n})\n\nif (__DEV__) {\n  TabList.displayName = \"TabList\"\n}\n\nexport interface TabPanelProps extends HTMLChakraProps<\"div\"> {}\n\n/**\n * TabPanel\n * Used to render the content for a specific tab.\n */\nexport const TabPanel = forwardRef<TabPanelProps, \"div\">((props, ref) => {\n  const panelProps = useTabPanel({ ...props, ref })\n  const styles = useStyles()\n\n  return (\n    <chakra.div\n      outline=\"0\"\n      {...panelProps}\n      className={cx(\"chakra-tabs__tab-panel\", props.className)}\n      __css={styles.tabpanel}\n    />\n  )\n})\n\nif (__DEV__) {\n  TabPanel.displayName = \"TabPanel\"\n}\n\nexport interface TabPanelsProps extends HTMLChakraProps<\"div\"> {}\n\n/**\n * TabPanel\n *\n * Used to manage the rendering of multiple tab panels. It uses\n * `cloneElement` to hide/show tab panels.\n *\n * It renders a `div` by default.\n */\nexport const TabPanels = forwardRef<TabPanelsProps, \"div\">((props, ref) => {\n  const panelsProps = useTabPanels(props)\n  return (\n    <chakra.div\n      {...panelsProps}\n      width=\"100%\"\n      ref={ref}\n      className={cx(\"chakra-tabs__tab-panels\", props.className)}\n    />\n  )\n})\n\nif (__DEV__) {\n  TabPanels.displayName = \"TabPanels\"\n}\n\nexport interface TabIndicatorProps extends HTMLChakraProps<\"div\"> {}\n\n/**\n * TabIndicator\n *\n * Used to render an active tab indicator that animates between\n * selected tabs.\n */\nexport const TabIndicator = forwardRef<TabIndicatorProps, \"div\">(\n  (props, ref) => {\n    const indicatorStyle = useTabIndicator()\n    const style = {\n      ...props.style,\n      ...indicatorStyle,\n    }\n\n    const styles = useStyles()\n\n    return (\n      <chakra.div\n        ref={ref}\n        {...props}\n        className={cx(\"chakra-tabs__tab-indicator\", props.className)}\n        style={style}\n        __css={styles.indicator}\n      />\n    )\n  },\n)\n\nif (__DEV__) {\n  TabIndicator.displayName = \"TabIndicator\"\n}\n"],"sourceRoot":""}